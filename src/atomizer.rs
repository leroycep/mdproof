use cmark::{Event as ParseEvent, Parser, Tag};
use std::borrow::Cow;
use style::{Class, Style};
use util::{slice_cow_till_idx, slice_cow_from_idx};

pub struct Atomizer<'src> {
    state: AtomizerState<'src>,
    parser: Parser<'src>,
    current_style: Style,
    is_code: bool,
    is_alt_text: bool,
}

#[derive(Debug)]
enum AtomizerState<'src> {
    /// The atomizer is splitting text apart
    Splitting(Cow<'src, str>),
    /// The atomizer is matching events generated by the markdown parser
    Parsing,
}

#[derive(Debug)]
pub enum Event<'src> {
    Atom(Atom<'src>),
    Break(Break),
    StartBlock(BlockTag),
    EndBlock(BlockTag),
}

#[derive(Debug)]
pub enum Atom<'src> {
    Text { text: Cow<'src, str>, style: Style },
    Image { uri: Cow<'src, str> },
}

#[derive(Debug)]
pub enum Break {
    Word,
    Line,
    Paragraph,
    HorizontalRule,
    Page,
}

#[derive(Debug)]
pub enum BlockTag {
    BlockQuote,
    CodeBlock,
    List(Option<usize>),
    ListItem,
}

impl<'src> Iterator for Atomizer<'src> {
    type Item = Event<'src>;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            let state = ::std::mem::replace(&mut self.state, AtomizerState::Parsing);
            let (next_event, next_state) = match state {
                AtomizerState::Parsing => match self.parser.next() {
                    Some(parser_event) => self.parse_event(parser_event),
                    None => break,
                },
                AtomizerState::Splitting(text) => self.split_text(text),
            };
            self.state = next_state;
            if next_event.is_some() {
                return next_event;
            }
        }
        None
    }
}

impl<'src> Atomizer<'src> {
    pub fn new(parser: Parser<'src>) -> Self {
        Atomizer {
            state: AtomizerState::Parsing,
            parser: parser,
            current_style: Style::default(),
            is_code: false,
            is_alt_text: false,
        }
    }

    fn split_text(&mut self, text: Cow<'src, str>) -> (Option<Event<'src>>, AtomizerState<'src>) {
        if text.len() == 0 || self.is_alt_text {
            return (None, AtomizerState::Parsing);
        }
        match text.chars().next().expect("string len must be > 0") {
            ' ' => if self.is_code {
                return (
                    Some(Event::Atom(Atom::Text {
                        text: " ".into(),
                        style: self.current_style.clone(),
                    })),
                    AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                );
            } else {
                return (
                    Some(Event::Break(Break::Word)),
                    AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                );
            },
            '\n' => {
                return (
                    Some(Event::Break(Break::Line)),
                    AtomizerState::Splitting(slice_cow_from_idx(&text, 1)),
                )
            }
            _ => {}
        }
        if text
            .chars()
            .next()
            .map(|c| c.is_whitespace())
            .unwrap_or(false)
        {
            return (None, AtomizerState::Splitting(slice_cow_from_idx(&text, 1)));
        }
        let style = self.current_style.clone();
        for (idx, c) in text.char_indices() {
            let end = match c {
                ' ' | '\n' => Some(idx),
                _ => None,
            };
            if let Some(idx) = end {
                let remainder = slice_cow_from_idx(&text, idx);
                let text = slice_cow_till_idx(&text, idx);
                return (
                    Some(Event::Atom(Atom::Text { text, style })),
                    AtomizerState::Splitting(remainder),
                );
            }
        }
        (
            Some(Event::Atom(Atom::Text { text, style })),
            AtomizerState::Parsing,
        )
    }

    fn parse_event(
        &mut self,
        event: ParseEvent<'src>,
    ) -> (Option<Event<'src>>, AtomizerState<'src>) {
        match event {
            ParseEvent::Start(Tag::Strong) => self.current_style.insert(Class::Strong),
            ParseEvent::End(Tag::Strong) => self.current_style.remove(&Class::Strong),
            ParseEvent::Start(Tag::Emphasis) => self.current_style.insert(Class::Emphasis),
            ParseEvent::End(Tag::Emphasis) => self.current_style.remove(&Class::Emphasis),
            ParseEvent::Start(Tag::Code) => self.current_style.insert(Class::Code),
            ParseEvent::End(Tag::Code) => self.current_style.remove(&Class::Code),

            ParseEvent::Start(Tag::Rule) => {
                return (
                    Some(Event::Break(Break::HorizontalRule)),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(Tag::Rule) => {}

            ParseEvent::Start(Tag::Header(size)) => {
                self.current_style.insert(Class::Heading(size as u8))
            }
            ParseEvent::End(Tag::Header(size)) => {
                self.current_style.remove(&Class::Heading(size as u8));
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing);
            }

            ParseEvent::Start(Tag::List(first_number)) => {
                return (
                    Some(Event::StartBlock(BlockTag::List(first_number))),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(Tag::List(first_number)) => {
                return (
                    Some(Event::EndBlock(BlockTag::List(first_number))),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Start(Tag::Item) => {
                return (
                    Some(Event::StartBlock(BlockTag::ListItem)),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(Tag::Item) => {
                return (
                    Some(Event::EndBlock(BlockTag::ListItem)),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Start(Tag::BlockQuote) => {
                return (
                    Some(Event::StartBlock(BlockTag::BlockQuote)),
                    AtomizerState::Parsing,
                )
            }
            ParseEvent::End(Tag::BlockQuote) => {
                return (
                    Some(Event::EndBlock(BlockTag::BlockQuote)),
                    AtomizerState::Parsing,
                )
            }

            ParseEvent::Text(text) => return (None, AtomizerState::Splitting(text)),

            ParseEvent::Html(html) => {
                use scraper::Html;
                let fragment = Html::parse_fragment(&html);

                for value in fragment.tree.values() {
                    let style_option = value.as_element().map(|e| e.attr("style")).unwrap_or(None);
                    match style_option {
                        Some("page-break-after:always;") => {
                            return (Some(Event::Break(Break::Page)), AtomizerState::Parsing);
                        }
                        _ => {}
                    }
                }
            }

            ParseEvent::Start(Tag::Image(uri, _title)) => {
                self.is_alt_text = true;
                return (
                    Some(Event::Atom(Atom::Image { uri })),
                    AtomizerState::Parsing,
                );
            }
            ParseEvent::End(Tag::Image(_url, _title)) => {
                self.is_alt_text = false;
            }

            ParseEvent::Start(Tag::CodeBlock(_src_type)) => {
                self.is_code = true;
                self.current_style.insert(Class::Code);
                self.current_style.insert(Class::Code);
                return (
                    Some(Event::StartBlock(BlockTag::CodeBlock)),
                    AtomizerState::Parsing,
                );
            }
            ParseEvent::End(Tag::CodeBlock(_)) => {
                self.is_code = false;
                self.current_style.remove(&Class::Code);
                return (
                    Some(Event::EndBlock(BlockTag::CodeBlock)),
                    AtomizerState::Parsing,
                );
            }

            ParseEvent::Start(Tag::Paragraph) => {}
            ParseEvent::End(Tag::Paragraph) => {
                return (Some(Event::Break(Break::Paragraph)), AtomizerState::Parsing)
            }

            ParseEvent::SoftBreak => {
                return (Some(Event::Break(Break::Word)), AtomizerState::Parsing)
            }
            ParseEvent::HardBreak => {
                return (Some(Event::Break(Break::Line)), AtomizerState::Parsing)
            }

            _ => {}
        };
        (None, AtomizerState::Parsing)
    }
}
